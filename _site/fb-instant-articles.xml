<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <description>
      The homepage for Mila's Math Bootcamp
    </description>
    
        
            <item>
                <title>The Derivative</title>
                <link>http://localhost:4000/machinelearning/basics/2019/07/23/the-derivative/</link>
                <content:encoded>
                    <![CDATA[
                    <blockquote>
  <p>“Whatcha doing George?” “Oh nothing Lenny, just working out some gradients.” “On paper? I’m not sure if you’ll be able to call <code class="highlighter-rouge">loss.backward()</code> there.</p>
</blockquote>

<hr />

<p>Machine learning, especially deep learning, is built almost entirely on differentiation. In this post, we will briefly describe differentiation, derivatives, and gradients. From there, we will continue on to discuss their connection to the underlying core idea behind many popular deep learning frameworks: automatic differentiation.</p>

<p>&lt;a href="https://colab.research.google.com/drive/1pD4Lnr1Gs8S3KiUT86D1zZzpWlHOBWRQ” target="_parent"&gt;&lt;img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/&gt;&lt;/a&gt;</p>

<h2 id="derivatives">Derivatives</h2>

<p>While derivatives can be explained and generalized to quite <a href="#TODO">a</a> <a href="#TODO">few</a> <a href="#TODO">domains</a>, we will start with the most elementary formulation: in the case of a function of a single, real-valued variable.</p>

<p>Concretely, a derivative in this setting measures sensitivity of change of the output with respect to its input: graphically in one dimension, this is the slope of the tangent line at $f(x)$; in physics, we often hear that the rate of change in position (output) with respect to time (input) is <em>velocity</em>, and similarly for velocity and acceleration.</p>

<p>![TODO - Links need to be fixed][../images/the-derivative/sincos.gif]</p>

<p>Derivatives can be generalized to both higher orders and higher dimensions. Higher orders of derivatives are just differentiating with respect to the input once again; for example, the second order derivative of position with respect to time brings us back to acceleration.</p>

<p>To understand higher dimensional derivatives, we can introduce <em>partial derivatives</em>. When given vector-values input $\vec{x}$, a partial erivative is just a derivative of the output with repsect to a particular <em>component</em> of $\vec{x}$. When dealing with scalar-valued functions (i.e the output is a scalar, or notationally, $f: \mathbb{R}^n \rightarrow \mathbb{R}), the vector of first order partial derivatives is called the <em>gradient</em>. If the output itself is vector-valued, the matrix of first-order partial derivatives is called the <em>Jacobian</em>; in fact, the Jacobian is just a generalization of the gradient.</p>

<p>Just as the derivative of a real-valued function is the slope of the tangent line, the gradient’s direction is the <em>direction of greatest increase</em>, where the rate of that increase is given by the magnitude. Often, we will use the notation $\nabla f(\vec{x})$ to denote the gradient notationally.</p>

<p>In machine learning, we are generally concerned with scalar-valued functions, so we focus our attention mostly on the gradient. While higher-order derivatives of scalar-valued functions are used in machine learning (the matrix of second-order derivatives of a vector-valued function is called the <em>Hessian</em>, and when the derivatives are taken with respect to parameters instead of the inputs,the matrix is called the <em>Fisher Information Matrix</em>), they deserve to be covered in their own post, and are not central to discussion here.</p>

<h2 id="machine-learning-and-gradients">Machine Learning and Gradients</h2>

<p>In machine learning, we care about <em>objective functions</em> and how to optimize them, whether we are working with supervised, deep, reinforcement, … learning. To optimize a function, we look for <em>optima</em>, or where $\nabla f(\vec{x}) = 0$ and the second-derivative test passes with the condition we’re looking for.</p>

<p>While generally, we can’t make the assumption that our objective function is convex (which means that we can’t guarantee that any local optima are globally optimal), we can still use gradients to find local minima (or maxima, depending on the problem we’re trying to solve).</p>

<p>This gives rise to algorithms like <em>gradient descent</em> (or more popularlly, the more efficient <em>stochastic</em> version); since we know that our gradient gives us the direction of fastest increase, we (to minimize an objective) can follow it in the ecact opposite direction.</p>

<p>While just following gradients can get us into trouble as well (saddles also have $\nabla f(\vec{x}) = 0$ just like optima, and unfortunately, it seems that <a href="#TODO">saddles are ubiquitous in nonconvex optimization</a>; SGD is generally considered to be effective at escaping these saddles, but the dynamics of gradient descent algorithms is still an <a href="#TODO">active area of research</a>), we defer those discussions to a later post.</p>

<h2 id="calculating-gradients-numerically">Calculating Gradients, Numerically</h2>

<p>To understand the numerical calculation of gradients, we must refer back to the defintion of derivatives, in terms of limits:</p>

<p>$ f’(a) = \lim_{h\rightarrow 0} \frac{f(a + h) - f(a)}{h} $</p>

<p>However, since limits are a theoretical tool, they offer us no help in the calculation of gradients in practice.</p>

<p>Numerically, we can replace the infinitetesimal $h$ with an arbitrarily small one, leading us to approximate the derivative as:</p>

<p>$ f’(a) \approx \lim_{h\rightarrow 0} \frac{f(a + h) - f(a)}{h} $</p>

<p>known as a <em>first-order divided difference</em>.</p>

<p>Numerical differentation (known as <em>differential quadrature</em>) are still the leading methods to solve partial differential equations (and are used to calculate derivatives in your favorite graphing calculator as well!), they incur errors on an order of magnitude of $h$; first-order divided differences incurs errors on the order of $O(h)$, and while improved methods such as symmetric divided difference can lower this, differential quadrature methods can be prone to floating point approximation errors and implementation efficiency issues.</p>

<h2 id="calculating-gradients-automagically">Calculating Gradients, Automagically</h2>

<h3 id="from-symbolic-to-automatic">From Symbolic to Automatic</h3>

<h3 id="the-chain-rule">The Chain Rule</h3>

<h3 id="sum-of-the-parts-are-greater-than-the-whole">Sum of the Parts are Greater than the Whole</h3>

<p>A section on how simple arithmetic operations and simple functions can be composed to efficiently calculate derivatives.</p>

<h3 id="forward-mode-and-backward-mode">Forward Mode and Backward Mode</h3>


                    ]]>
                </content:encoded>
                <guid isPermaLink="false">/machinelearning/basics/2019/07/23/the-derivative/</guid>
                <description>
                    
                    Learn about derivatives and gradients.
                    
                </description>
                <pubDate>Tue, 23 Jul 2019 08:22:18 -0400</pubDate>
                <author>Bhairav Mehta</author>
            </item>
        
    
  </channel>
</rss>
